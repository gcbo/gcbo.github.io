<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>angr源码分析之CFGFast分析之一</title>
      <link href="/2020/03/01/angr%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BCFGFast%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/"/>
      <url>/2020/03/01/angr%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BCFGFast%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="angr源码分析之CFGFast分析之一"><a href="#angr源码分析之CFGFast分析之一" class="headerlink" title="angr源码分析之CFGFast分析之一"></a>angr源码分析之CFGFast分析之一</h1><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFGBase: Analysis，CFG分析要继承此类</span><br><span class="line">CFGFast: ForwardAnalysis,CFGBase</span><br><span class="line">Analysis：angr中的分析方法都必须继承此类。</span><br><span class="line">ForwardAnalysis: 提供一个遍历CFG的前向分析框架;如果没有CFG，则用生成CFG的框架生成新的CFG。</span><br></pre></td></tr></tbody></table></figure></div><h2 id="生成CFG的框架-ForwardAnalysis"><a href="#生成CFG的框架-ForwardAnalysis" class="headerlink" title="生成CFG的框架(ForwardAnalysis)"></a>生成CFG的框架(ForwardAnalysis)</h2><h3 id="如何解析"><a href="#如何解析" class="headerlink" title="如何解析"></a>如何解析</h3><p>给一个地址，解析直到跳转即为一个代码块，在框架中为一个个job，代码块就是节点，从一个代码块跳转到另一个代码块构成一条边，最终构成分析程序的<strong>CFG(control flow graph)</strong>。</p><h3 id="解析job的过程收集的信息"><a href="#解析job的过程收集的信息" class="headerlink" title="解析job的过程收集的信息"></a>解析job的过程收集的信息</h3><ol><li>整个程序CFG的信息，其中每个节点都是一个代码块，每个代码块的出口是使流程发生跳转的语句，如jmpxx,call,ret等，这些跳转信息构成了CFG的边。</li><li>各个函数的CFG信息。</li></ol><h3 id="一个job有哪些信息"><a href="#一个job有哪些信息" class="headerlink" title="一个job有哪些信息"></a>一个job有哪些信息</h3><ol><li>表示要接下来要从哪个地址开始分析。</li><li>分析的地址属于哪个函数。</li><li>哪个节点产生了这个job。</li><li>这个job与哪些函数边有关。</li></ol><h3 id="有两种job队列"><a href="#有两种job队列" class="headerlink" title="有两种job队列"></a>有两种job队列</h3><ol><li>通过正常跳转(call jmpxx)生成的job。</li><li>从某个函数返回的地址生成pendding job，只有正常的用完了，才会用pending job中的job。</li></ol><h3 id="分析过程中有哪些难点"><a href="#分析过程中有哪些难点" class="headerlink" title="分析过程中有哪些难点"></a>分析过程中有哪些难点</h3><p>主要就是跳转的目的地址的解析</p><ol><li>call/jmpxx eax </li><li>call/jmpxx [mem+eax*0x4]</li><li>call/jmpxx [mem]</li></ol><p>在angr中这些类型的跳转成为间接跳转，需要额外的解析，如IAT解析，或使用符号执行以及程序切片去解析这些间接跳转地址。</p><h3 id="分析框架"><a href="#分析框架" class="headerlink" title="分析框架"></a>分析框架</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. _analyze</span><br><span class="line">    a. _pre_analysis</span><br><span class="line">    b. _analysis_core_baremetal(这是一个循环，从job队列中获取job，分析生成新的job，直到job队列为空)</span><br><span class="line">        1) _pre_job_handling(抽象接口，CFGFast实现)</span><br><span class="line">        2) _process_job_and_get_successors(输入当前job)</span><br><span class="line">            a) _get_successors (抽象接口,CFGFast实现,处理一个job，得到successors)</span><br><span class="line">            对于每一个successor调用</span><br><span class="line">                i) _handle_successor(抽象接口,输出job)</span><br><span class="line">                ii) _insert_job(输入job，将job放入job队列中)</span><br><span class="line">            c) _post_job_handling(抽象接口)</span><br><span class="line">        3) _intra_analysis(抽象接口)</span><br></pre></td></tr></tbody></table></figure></div><h2 id="CFGFast的实现"><a href="#CFGFast的实现" class="headerlink" title="CFGFast的实现"></a>CFGFast的实现</h2><pre><code>a.  _get_successors(输入job，返回新产生的jobs)    i. _scan_block        1) _scan_irsb            a) _generate_cfgnode(生成CFGNode，一个代码块就是一个节点)                i) 用factory.block生成一个vex block代码块                ii) 提取irsb                iii) 生成CFGNode            b)  apply_function_edges(为这个job相关的函数CFG添加边)            c) _graph_add_edge(为整个CFG添加边，需要有源节点(通过job得知)，目的节点，以及跳转类型)            d) _function_add_node            e) _create_jobs(输入出口跳转地址,跳转类型)                i) 如果跳转的地址不是具体值                    a). 如果是ret,为当前函数添加一个出口，设置当前函数能返回，设置当前节点为已经返回                    b). 这是一个间接跳转，尝试解析这个地址，如果能解析                        1). 如果跳转为call,调用_create_job_call                         2). 如果跳转不是call,创建FunctionTransitionEdge，表示这是函数中的一个转移边，创建job，返回                ii) 如果是具体值                    a). 如果跳转类型为call,调用_create_job_call                     b). 如果不是call，创建FunctionTransitionEdge，表示这是函数中的一个转移边，创建job，返回1. _create_job_call    a. 如果跳转目的地址不是空        i. 创建functioncalledge，表示这是函数中的一个调用边        ii. 创建job，添加job。        iii. 获取callee函数，即跳转地址代表的函数            1) 如果没有，将caller的下一个指令设为返回地址，添加functionfakeretedge，添加job到pending队列中，也就是解析caller的下一指令            2) 如果有，且不能返回，则退出，如能返回,将caller的下一个指令设为返回地址，添加functionfakeretedge，添加job到pending队列中                </code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> static program analysis </category>
          
          <category> control flow graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angr源码分析之中间语言VEX</title>
      <link href="/2020/03/01/angr%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80vex/"/>
      <url>/2020/03/01/angr%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80vex/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="angr源码分析之中间语言VEX"><a href="#angr源码分析之中间语言VEX" class="headerlink" title="angr源码分析之中间语言VEX"></a>angr源码分析之中间语言VEX</h1><h2 id="什么是中间语言"><a href="#什么是中间语言" class="headerlink" title="什么是中间语言"></a>什么是中间语言</h2><blockquote><p>二进制代码 –> 汇编代码 –> 中间语言  </p></blockquote><p>这是与具体的底层架构无关的中间语言</p><ol><li>用偏移表示寄存器，可以映射到真正的底层架构中</li><li>无指令副作用，如一些pop，push操作还更改了esp的值，该指令由副作用，在指令的运行过程中改变了其他值的内容，在vex中指令是无副作用的</li><li>vex引入了临时变量，用于存储内存、寄存器值</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="x86代码"><a href="#x86代码" class="headerlink" title="x86代码"></a>x86代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0042f225 66  83  7a       CMP        word ptr [EDX  + 0x6 ],0x1f</span><br><span class="line">         06  1f</span><br><span class="line">0042f22a 77  14           JA         0x0042f420</span><br></pre></td></tr></tbody></table></figure></div><h3 id="VEX代码"><a href="#VEX代码" class="headerlink" title="VEX代码"></a>VEX代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00 | ------ IMark(0x42f225, 5, 0) ------</span><br><span class="line">01 | t5 = GET:I32(edx)</span><br><span class="line">02 | t4 = Add32(t5,0x00000006)</span><br><span class="line">03 | t2 = LDle:I16(t4)</span><br><span class="line">04 | PUT(cc_op) = 0x00000005</span><br><span class="line">05 | t6 = 16Uto32(t2)</span><br><span class="line">06 | PUT(cc_dep1) = t6</span><br><span class="line">07 | PUT(cc_dep2) = 0x0000001f</span><br><span class="line">08 | PUT(cc_ndep) = 0x00000000</span><br><span class="line">09 | PUT(eip) = 0x0042f22a</span><br><span class="line">10 | ------ IMark(0x42f22a, 2, 0) ------</span><br><span class="line">11 | t13 = x86g_calculate_condition(0x00000006,0x00000005,t6,0x0000001f,0x00000000):Ity_I32</span><br><span class="line">12 | t8 = 32to1(t13)</span><br><span class="line">13 | if (t8) { PUT(eip) = 0x42f22c; Ijk_Boring }</span><br><span class="line">NEXT: PUT(eip) = 0x0042f240; Ijk_Boring</span><br></pre></td></tr></tbody></table></figure></div><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>• RdTmp(t10) 读临时变量<br>• GET:I32(16) 读寄存器<br>• LDIe:I32 读内存</p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>• WrTmp 写临时变量<br>• Put 写寄存器<br>• Stle 写内存</p><h2 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h2><p>如add sub等，都是在临时变量之间运算</p><h2 id="IR-expression"><a href="#IR-expression" class="headerlink" title="IR expression"></a>IR expression</h2><p>如读操作，常量，if else then,运算操作</p><h2 id="IR-statement"><a href="#IR-statement" class="headerlink" title="IR statement"></a>IR statement</h2><p>等号左边表示IR statement的操作类型<br>如，条件跳转<br>WrTmp(t1) = (IR Expression) </p><h2 id="IRSB-代码块"><a href="#IRSB-代码块" class="headerlink" title="IRSB(代码块)"></a>IRSB(代码块)</h2><p>最后的指令是某种形式的跳转,一定是PUT(eip)<br>一般为以下两种形式</p><ol><li>WrTmp(tmp )=(IR expression) PUT(eip)=tmp</li><li>PUT(reg)=(IR expression) PUT(eip)=reg</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> static program analysis </category>
          
          <category> IR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angr </tag>
            
            <tag> vex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL注入</title>
      <link href="/2020/03/01/DLL%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/03/01/DLL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><h2 id="何为DLL注入"><a href="#何为DLL注入" class="headerlink" title="何为DLL注入"></a>何为DLL注入</h2><p>向一个正在运行的进程中注入代码，代码是以动态链接库的形式存在。</p><h2 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h2><p>大部分注入技术都有以下几个步骤</p><ol><li>附加到目标/远程进程</li><li>在目标/远程进程内分配内存</li><li>将DLL文件路径，或者DLL文件，复制到目标/远程进程的内存空间</li><li>控制进程运行某个函数载入DLL</li></ol><p>载入DLL的方式可以分为两类</p><ol><li>通过loadlibrary</li><li>不通过loadlibrary</li></ol><h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a><a href="https://github.com/fdiskyou/injectAllTheThings" target="_blank" rel="noopener">技术介绍</a></h2><ul><li>CreateRemoteThread()</li><li>NtCreateThreadEx()</li><li>QueueUserAPC()</li><li>SetWindowsHookEx()</li><li>RtlCreateUserThread()</li><li>SetThreadContext()</li><li><a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">反射DLL</a></li></ul><h3 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h3><ol><li>附加到目标进程</li><li>在目标进程中分配内存<ol><li>为dll名字分配内存</li><li>或为dll分配内存</li><li>或为代码分配内存</li></ol></li><li>向目标进程内存写入内容<ol><li>写dll的路径</li><li>或写入整个dll</li><li>或写入代码</li></ol></li><li>创建线程运行程序，运行某个地址的函数，<ol><li>通过CreateRemoteThreadW / NtCreateThreadEx/ RtlCreateUserThread 创建线程</li><li>通过QueueUserAPC,向指定线程APC队列中添加一个用户态的异步过程APC象，这是一个线程事件，所以要OpenThread,在这个事件设有回调函数，一旦换到此线程，发现队列中有此对象，则调用回调函数</li><li>通过SetWindowsHookEx，针对线程收到的某一特定消息设置回调函数，回函数在dll中，输入回调函数在dll中的地址，以及dll句柄，线程id，输出句柄</li><li>通过SetThreadContext，主动挂起线程，通过线程id获取进程上下文，也是栈，寄存器的内容，重新构造栈结构和返回地址，恢复线程之后则程序流程改变，切换到新设置的返回地址处运行，返回地址处要有代码用于载入dll</li><li>通过反射式dll，模拟载入dll的过程，这样可以隐藏dll，注入的dll需要含一个导出函数ReflectiveLoader</li></ol></li></ol><h3 id="如何载入DLL"><a href="#如何载入DLL" class="headerlink" title="如何载入DLL"></a>如何载入DLL</h3><h4 id="通过LoadLibrary"><a href="#通过LoadLibrary" class="headerlink" title="通过LoadLibrary"></a>通过LoadLibrary</h4><h4 id="不通过LoadLibrary"><a href="#不通过LoadLibrary" class="headerlink" title="不通过LoadLibrary"></a>不通过LoadLibrary</h4><p>模拟载入dll</p><ol><li>将dll文件写入远程进程内存</li><li>让进程执行ReflectiveLoader<ol><li>开辟dll内存映像大小的新内存</li><li>从PEB结构中获取GetProcessAddress,LoadLibrary</li><li>遍历导入表，载入所以来的导入库，获取导入函数真实地址，完成IAT的重写</li><li>根据重定位表完成重定位</li><li>获取入口地址并调用</li></ol></li></ol><h5 id="为何要在注入的dll中包含ReflectiveLoader"><a href="#为何要在注入的dll中包含ReflectiveLoader" class="headerlink" title="为何要在注入的dll中包含ReflectiveLoader"></a>为何要在注入的dll中包含ReflectiveLoader</h5><p>在目标进程中调用ReflectiveLoader完成模拟载入</p><h3 id="如何让目标进程执行载入DLL功能的函数"><a href="#如何让目标进程执行载入DLL功能的函数" class="headerlink" title="如何让目标进程执行载入DLL功能的函数"></a>如何让目标进程执行载入DLL功能的函数</h3><h4 id="调用API创建线程执行函数"><a href="#调用API创建线程执行函数" class="headerlink" title="调用API创建线程执行函数"></a>调用API创建线程执行函数</h4><ol><li>CreateRemoteThreadW / NtCreateThreadEx /RtlCreateUserThread<ol><li>OpenProcess，访问权限设为，内存可操作，内存可读写，可创建线程。得到程序句柄</li><li>VirtualAllocEx,在目标进程中分配内存，返回地址</li><li>WriteProcessMemory,向获取的内存地址中写入内容，此处为 dll 路径</li><li>获取kernel32.dll中 LoadLibraryW的地址，GetProcAddress</li><li>CreateRemoteThread /NtCreateThreadEx/RtlCreateUserThread，在目标进程中创建新线程，运行地址设为LoadLibraryW，参数设为步骤c获得的dll路径地址</li></ol></li></ol><h4 id="设置事件回调函数"><a href="#设置事件回调函数" class="headerlink" title="设置事件回调函数"></a>设置事件回调函数</h4><p>通过QueueUserAPC/SetWindowsHookEx</p><ol><li>通过QueueUserAPC,向指定线程APC队列中添加一个用户态的异步过程APC象，这是一个线程事件，所以OpenThread获得一个已有的线程,在这个事件设有回调函数，一旦换到此线程，发现队列中有此对象，则调用回调函数</li><li>通过SetWindowsHookEx，针对线程收到的某一特定消息设置回调函数，回函数在dll中，输入回调函数在dll的地址，以及dll句柄，线程id，输出句柄</li></ol><h4 id="通过suspend-inject-resume"><a href="#通过suspend-inject-resume" class="headerlink" title="通过suspend-inject-resume"></a>通过suspend-inject-resume</h4><p>通过SetThreadContext，主动挂起线程，通过线程id获取进程上下文，也是栈，寄存器的内容，重新构造栈构和返回地址，恢复线程之后则程序流程改变，切换到新设置的返回地址处运行，返回地址处要有代码用于载入dll</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> DLL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是AST?</title>
      <link href="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AFAST/"/>
      <url>/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AFAST/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="什么是AST"><a href="#什么是AST" class="headerlink" title="什么是AST"></a>什么是AST</h1><p>大部分编译器的工作可以被分解为三个主要阶段：解析（Parsing），转化（Transformation）以及代码生成（Code Generation）。</p><blockquote><ol><li><strong>解析</strong> 将源代码转换为一个更抽象的形式。</li><li><strong>转换</strong> 接受解析产生的抽象形式并且操纵这些抽象形式做任何编译器想让它们做的事。</li><li><strong>代码生成</strong> 基于转换后的代码表现形式（code representation）生成目标代码。</li></ol></blockquote><p><strong>解析</strong></p><blockquote><p>解析一般被分为两个部分：词法分析和语法分析。</p><ol><li><strong>词法分析</strong> 通过一个叫做tokenize的工具将源代码分解成一个个token。token是描述编程语言语法的对象。它可以描述数字，标识符，标点符号，运算符等等。</li><li><strong>语法分析</strong> 接收token并将它们组合成一个描述了源代码各部分关系的中间表达形式：抽象语法树。<br><strong>抽象语法树</strong>是一个深度嵌套的对象，这个对象以一种既能够地操作又提供很多关于源代码信息的形式来展现代码。</li></ol></blockquote><p><strong>词法分析</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8*1+2</span><br></pre></td></tr></tbody></table></figure></div><p>编译器的工作就是将字符串形式源代码转化为二进制可执行代码。<br>词法、语法分析前要了解如何描述一门语言，即这门语言的语法规则。通常用<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" target="_blank" rel="noopener">BNF</a>范式表示语法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">token 解析规则</span><br><span class="line">PLUS : +</span><br><span class="line">MINUS : -</span><br><span class="line">MUL : *</span><br><span class="line">DIV : / </span><br><span class="line">INTEGER : 1|2|3|4|5|6|7|8|9</span><br><span class="line">LPAREN : (</span><br><span class="line">RPAREN : )</span><br><span class="line">space : </span><br><span class="line">parser 解析规则</span><br><span class="line">expr   : term ((PLUS | MINUS) term)*</span><br><span class="line">term   : factor ((MUL | DIV) factor)*</span><br><span class="line">factor : INTEGER | LPAREN expr RPAREN</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">词法分析</a><br>识别一个个单词，解析为一个个token，要指明解析的符号的类型及其值，如8，类型是INTEGER,值为8，最终解析的token流为，INTEGER MUL INTEGER PLUS INTEGER。<br><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">语法分析</a><br>输入token流，解析为一棵AST(Abstract Syntax Trees，由节点组织成一棵树)，共有3个规则，包含3个解析子函数。</p><ol><li>根据规则expr，第一个token要用term规则解析得到节点作为左子节点，把PLUS或MINIS当作父节点，下一个token用term解析得到右节点。</li><li>根据规则term，第一个token要用factor解析得到节点作为左子节点，把MUL或DIV当作父节点，下一个token用factor解析得到右节点。</li><li>根据规则factor,第一个token是INTEGER或LPAREN，如果是INTEGER,返回一个AST节点，值为token的值;如果是LPAREN,则用规则expr解析下一个token，也就是在AST中没有括号。</li></ol><h2 id="如何计算AST表示的表达式"><a href="#如何计算AST表示的表达式" class="headerlink" title="如何计算AST表示的表达式"></a>如何计算AST表示的表达式</h2><p>非叶子节点都是代表一种操作，叶子节点是值，遍历的过程如果遇到节点是操作符，那么继续遍历改节点直到叶节点。<br>以上的AST的生成过程是针对表达式的，但是整个程序都可以用AST表示。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> static program analysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态程序分析</title>
      <link href="/2020/02/25/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/25/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="静态程序分析"><a href="#静态程序分析" class="headerlink" title="静态程序分析"></a>静态程序分析</h1><h2 id="程序的表示"><a href="#程序的表示" class="headerlink" title="程序的表示"></a>程序的表示</h2><p><strong>AST(Abstract Syntax Trees)</strong></p><blockquote><p>这种分析忽略了函数或块中语句的执行顺序，这使得AST成为一种方便的表示。</p></blockquote><p><strong>Control Flow Graph</strong></p><h2 id="基于抽象解释的程序分析"><a href="#基于抽象解释的程序分析" class="headerlink" title="基于抽象解释的程序分析"></a>基于抽象解释的程序分析</h2><h3 id="基于CFG的数据流分析"><a href="#基于CFG的数据流分析" class="headerlink" title="基于CFG的数据流分析"></a>基于CFG的数据流分析</h3><blockquote><p>程序可以看成是状态（数据）和状态之间的转移（控制）两部分，分析状态数据在转移过程中的变化，叫做<strong>数据流分析</strong>。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x*=<span class="number">-100</span>;</span><br><span class="line">y+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y < z) {</span><br><span class="line">x *=<span class="number">-100</span>;</span><br><span class="line">y += <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>如果输入的x，y，z为正，负数，零，运行结果正负是什么？</p></blockquote><p>这里并未考虑xyz具体值是什么。而是考虑其正负情况，这就是一个抽象结果，也是一种近似的结果。<br><strong>具体域</strong><br>程序运行的时变量具体的值构成的值域。<br><strong>具体语法规则</strong><br>针对具体域的语句操作，如+， 8+7->15。这将改变程序具体状态。<br><strong>抽象域</strong><br>程序抽象运行时抽象状态(程序某一抽象属性构成的集合)，这取决于考虑的问题，输入的x>100,输出的结果是否满足x>100，就会有不同抽象域。<br><strong>抽象语法规则</strong><br>针对抽象域的语句操作规则，如抽象的+，正+正->正。将改变程序的抽象状态。<br><strong>应用数据流分析</strong></p><ol><li>构造相应的抽象域。</li><li>构造具体的语法对应的抽象语法规则。</li><li>输入抽象状态，遍历CFG，每遇到一个节点，用其对应的抽象语法规则计算相应的抽象状态作为该节点的输出。达到fixpoint为止，即所有的节点的状态没发生改变。</li></ol><p><strong>状态合并</strong></p><blockquote><p>给定一条路径计算抽象状态输出<br>给定多条路径计算抽象状态输出，这多条路径的遍历是否有先后顺序？</p></blockquote><p>给出一条程序路径上的分析方案，和不同路径上的结果合并方案<br>• 近似方案1：忽略掉程序的条件判断，认为所有分支都有可能到达。<br>• 近似方案2：不在路径末尾做合并，在控制流汇合的所有位置提前做合并。</p><h4 id="不同的数据流分析"><a href="#不同的数据流分析" class="headerlink" title="不同的数据流分析"></a>不同的数据流分析</h4><p><strong>符号分析</strong><br>判断变量的符号，正负。<br><strong>常量传播分析</strong><br>判断一个变量是否是常量。<br><strong>Live Variables Analysis</strong><br>给定程序中的某条语句s和变量v，如果在s执行前保存在v中的值在后续执行中还会被读取就被称作活跃变量，一个变量在一个节点中被读了就是活跃的。<br><strong>Available Expression Analysis</strong><br>给定程序中某个位置p，如果从入口到p的所有路径都对表达式exp求值，并且最后一次求值后该表达式的所有变量都没有被修改，则exp称作p的一个可用表达式。给出分析寻找可用表达式。在到达一个节点之前，exp都是可用的，执行某个节点之后，被读的变量除去没被写的变量构成的exp是可用的。<br><strong>Reaching Definition Analysis</strong><br>某个节点执行后，变量赋值的位置。<br><strong>forward analysis</strong><br>对每个程序点计算有关过去行为的信息的分析。如符号分析和可用表达式分析。它们的特征是输出的抽象状态仅取决于CFG节点的父节点。因此，分析基本上从入口节点开始，并在CFG中向前传播信息。<br><strong>backward analysis</strong><br>针对每个程序点计算有关未来行为的信息。<br><strong>Internval analysis</strong><br>计算变量的上界和下界</p><ul><li>Widening：通过降低结果的精度来加快收敛速度。</li><li>Narrowing：对Widening的结果进行修正，使之更精确。</li></ul><h4 id="还需考虑的问题"><a href="#还需考虑的问题" class="headerlink" title="还需考虑的问题"></a>还需考虑的问题</h4><p>一般而言，抽象过程中考虑的信息越多，程序分析的精度就越高，但分析的速度就越慢。程序分析中考虑的信息通常用<strong>敏感性</strong>来表示<br><strong>流非敏感分析（flow-insensitive analysis）</strong>：如果把程序中语句随意交换位置（即：改变控制流），如果分析结果始终不变，则该分析为流非敏感分析。<br><strong>流敏感分析（flow-sensitive analysis）</strong>：其他情况<br><strong>路径非敏感分析</strong>：不考虑程序中的路径可行性，忽略分支循环语句中的条件<br><strong>路径敏感分析</strong>：考虑程序中的路径可行性，只分析可能的路径<br><strong>上下文非敏感分析(Context-insensitive analysis)</strong>：在过程调用的时候忽略调用的上下文<br><strong>上下文敏感分析(Context-sensitive analysis)</strong>：在过程调用的时候考虑调用的上下文</p><h3 id="基于Def-Use的数据流分析"><a href="#基于Def-Use的数据流分析" class="headerlink" title="基于Def-Use的数据流分析"></a>基于Def-Use的数据流分析</h3><p><strong>Def-Use</strong><br>给定变量x，如果结点A可能改变x的值，结点B可能使用结点A改变后的x的值，则结点A和结点B存在Def-Use关系，边用x表示。<br>这样可以构造一个新的图用于描述这种关系，A–>B。可以通过Reaching Definition Analysis得到def-use关系。</p><p><strong>静态单赋值形式(Single Static Assignment)</strong><br>每个变量都只被赋值一次，直接提供了Def-Use链。</p><p><strong>dominate</strong></p><ul><li>结点A支配（dominate）结点B：所有从Entry到B的路径都要通过A。</li><li>结点A严格支配（Strictly dominate）结点B：A支配B并且A和B不是一个结点。</li><li>A不严格支配B： 至少存在一条路径，在到达B之前不经过A。</li></ul><p><strong>支配边界(Dominance Frontier)</strong><br>结点A的支配边界中包括B，当且仅当</p><ul><li>A支配B的某一个前驱结点：至少有一条路径经过A，且B前面的结点不会有路径汇合的情况。</li><li>A不严格支配B：至少有一条路径没有经过A，且两条在B处汇合。</li></ul><p><strong>直接支配者(immediate dominator)</strong><br>如果a严格支配b，并且不存在c，a严格支配c且c严格支配b，则a是b的直接支配者，记为idom(b),直接支配关系构成一颗树，称为<strong>支配树</strong>，a–>b 。</p><h3 id="指针分析"><a href="#指针分析" class="headerlink" title="指针分析"></a>指针分析</h3><p>每个指针变量可能指向的内存位置，局部和全局变量在栈上的地址</p><h3 id="别名分析"><a href="#别名分析" class="headerlink" title="别名分析"></a>别名分析</h3><p>给定两个变量a, b，判断这两个变量是否指向相同的内存位置</p><h3 id="控制流分析"><a href="#控制流分析" class="headerlink" title="控制流分析"></a>控制流分析</h3><p>确定函数调用目标的分析</p><h4 id="控制流分析-vs-数据流分析"><a href="#控制流分析-vs-数据流分析" class="headerlink" title="控制流分析 vs 数据流分析"></a>控制流分析 vs 数据流分析</h4><blockquote><p>控制流分析确定程序控制的流向<br>数据流分析确定程序中数据的流向<br>数据流分析在控制流图上完成，因此控制流分析是数据流分析的基础</p></blockquote><h2 id="基于搜索的程序分析"><a href="#基于搜索的程序分析" class="headerlink" title="基于搜索的程序分析"></a>基于搜索的程序分析</h2><p>抽象与搜索的目的都是近似求解。<br>抽象：在可快速计算的抽象域上得到上近似或下近似结果。<br>搜索：尝试得到精确结果，如果超时就放弃。</p><h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><ul><li>SAT(布尔逻辑的可满足性问题SATISFIABLITY problem) solver：解著名的NP完全问题</li><li>Linear solvers：求线性方程组</li><li>Array solvers: 求解包含数组的约束</li><li>String solver：求解字符串约束</li><li>SMT(Satisfiability Modulo Theories)：综合以上各类约束求解工具</li></ul><h4 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a><a href="https://xiongyingfei.github.io/SA/2019/13_symbolic_execution.pdf" target="_blank" rel="noopener">符号执行</a></h4><h4 id="符号抽象-Symbolic-Abstraction"><a href="#符号抽象-Symbolic-Abstraction" class="headerlink" title="符号抽象(Symbolic Abstraction)"></a><a href="https://xiongyingfei.github.io/SA/2019/15_symbolic_abstraction.pdf" target="_blank" rel="noopener"><strong>符号抽象(Symbolic Abstraction)</strong></a></h4><p>利用SMT Solver的求解能力，自动找到函数的整体精确抽象，在抽象解释中使用约束求解，程序的抽象状态以某种约束的形式加入约束求解，约束求解的解还可以转换为抽象状态 抽象状态–>SMT–>抽象状态(精确提高)。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> static program analysis </category>
          
          <category> data flow analysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux配置及常用命令</title>
      <link href="/2020/02/23/linux%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/23/linux%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="安装linux备忘录"><a href="#安装linux备忘录" class="headerlink" title="安装linux备忘录"></a>安装linux备忘录</h1><h2 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h2><p>普通用户只需在命令前加上<strong>sudo</strong>，即可使用 <strong>root</strong>特权执行命令:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cmd</span><br></pre></td></tr></tbody></table></figure></div><p>用<strong>root</strong>登录执行<strong>visudo</strong>，添加：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER_NAME   ALL=(ALL) ALL</span><br><span class="line">Defaults:USER_NAME      !authenticate</span><br></pre></td></tr></tbody></table></figure></div><h2 id="配置pip源"><a href="#配置pip源" class="headerlink" title="配置pip源"></a>配置pip源</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux:"></a>linux:</h3><p>修改 <code>~/.pip/pip.conf</code> (没有就创建一个)， 添加：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure></div><h3 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h3><p>创建<code>C:\ProgramData\pip\pip.ini</code>，添加：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure></div><h2 id="manjaro设置国内源"><a href="#manjaro设置国内源" class="headerlink" title="manjaro设置国内源"></a>manjaro设置国内源</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman-mirrors -i -c China -m rank </span><br><span class="line">$ sudo pacman -Syy</span><br><span class="line">$ pacman -S archlinux-keyring</span><br></pre></td></tr></tbody></table></figure></div><h2 id="pwntools修复"><a href="#pwntools修复" class="headerlink" title="pwntools修复"></a>pwntools修复</h2><p><code>site-packages\pwnlib\term\termcap.py</code>第50行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curses.setupterm()</span></span><br><span class="line">curses.initscr()</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> pip </tag>
            
            <tag> sudo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FStoneCapture逆向分析</title>
      <link href="/2020/02/18/FStoneCapture%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/18/FStoneCapture%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><a href="http://www.faststone.org" target="_blank" rel="noopener">FastStone Capture</a> 是一款抓屏工具，体积小巧、功能强大。我也是在不经意间使用下载了此软件，并不知道这是一款商用软件，用了一段时间竟然出现使用结束对话框。<br> <a href="fs试用版本.PNG" data-fancybox="group" data-caption="试用版本" class="fancybox"><img width="40%" alt="试用版本" align="center" title="试用版本" data-src="fs试用版本.PNG" src="/img/loading.gif" class="lazyload"></a></p><p>本着好奇心和认真学习的态度尝试逆向此软件。</p><hr><h1 id="01-样本概况"><a href="#01-样本概况" class="headerlink" title="01-样本概况"></a>01-样本概况</h1><h2 id="1-1-应用程序信息"><a href="#1-1-应用程序信息" class="headerlink" title="1.1-应用程序信息"></a>1.1-应用程序信息</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">软件名称：FastStone Capture</span><br><span class="line">产品版本：9.0</span><br><span class="line">名称: FSCapture.exe</span><br><span class="line">大小: 5668864 字节 (5536 KiB)</span><br><span class="line">CRC32: F37FA650</span><br><span class="line">SHA256: 1D9620FE0004E48CBD382A110AD50EED913C85B7374ED1F02205DA1599460BE6</span><br><span class="line">SHA1: 49F715359E3CB092FFA2DD3432EFDFE1C11C4749</span><br><span class="line">这是一个汉化版本，以下结果英文版也适用。</span><br></pre></td></tr></tbody></table></figure></div><h2 id="1-2-分析环境及工具"><a href="#1-2-分析环境及工具" class="headerlink" title="1.2-分析环境及工具"></a>1.2-分析环境及工具</h2><ul><li>系统环境：Windows10-64位、Windows7-32位</li><li>工具：x64dbg、IDA、IDR-Delphi反编译</li></ul><h2 id="1-3-分析目标"><a href="#1-3-分析目标" class="headerlink" title="1.3-分析目标"></a>1.3-分析目标</h2><ul><li>分析算法</li></ul><h1 id="02-具体分析过程"><a href="#02-具体分析过程" class="headerlink" title="02-具体分析过程"></a>02-具体分析过程</h1><h2 id="2-1-可执行文件信息"><a href="#2-1-可执行文件信息" class="headerlink" title="2.1-可执行文件信息"></a>2.1-可执行文件信息</h2><ol><li>放入PEID<a href="fs_peid.png" data-fancybox="group" data-caption="程序注册框" class="fancybox"><img width="40%" alt="程序注册框" title="程序注册框" data-src="fs_peid.png" src="/img/loading.gif" class="lazyload"></a>Delphi编写，并且无壳。</li><li>运行程序，错误提示<a href="fs_注册框.png" data-fancybox="group" data-caption="错误提示" class="fancybox"><img width="40%" alt="错误提示" title="错误提示" data-src="fs_注册框.png" src="/img/loading.gif" class="lazyload"></a></li></ol><h2 id="2-2-定位关键函数"><a href="#2-2-定位关键函数" class="headerlink" title="2.2-定位关键函数"></a>2.2-定位关键函数</h2><ol><li><p>将程序载入x64dbg和IDR，在一些通获取用户输入的API下断点，或是搜错误提示字符串。</p><a href="fs_IDR_字符串搜索.png" data-fancybox="group" data-caption="IDR字符搜索结果" class="fancybox"><img width="40%" alt="IDR字符搜索结果" title="IDR字符搜索结果" data-src="fs_IDR_字符串搜索.png" src="/img/loading.gif" class="lazyload"></a>可以看出这个程序至少包含5种以上的许可证。</li><li><p>定位到以上字符串地址，能在附近找到注册回调函数。</p><a href="fs_IDR_按钮点击注册.png" data-fancybox="group" data-caption="注册按钮回调函数" class="fancybox"><img width="40%" alt="注册按钮回调函数" title="注册按钮回调函数" data-src="fs_IDR_按钮点击注册.png" src="/img/loading.gif" class="lazyload"></a>一旦定位了关键函数，分析已经是胜利一半了，接下来要结合x64dbg和IDR就能较快分析程序具体流程。</li></ol><h2 id="2-2-分析关键函数"><a href="#2-2-分析关键函数" class="headerlink" title="2.2-分析关键函数"></a>2.2-分析关键函数</h2><p>假设输入的名字为hello,注册码为APAMAIBDBBCCCCCDDDDD</p><ol><li>经过分析，可以了解到注册函数的整体框架，一共5次检测，无论那次失败，最终跳转到错误提示，检测1到5依次判断。<a href="fs_程序整体框架.png" data-fancybox="group" data-caption="程序整体框架" class="fancybox"><img width="40%" alt="程序整体框架" title="程序整体框架" data-src="fs_程序整体框架.png" src="/img/loading.gif" class="lazyload"></a></li><li>接下来看看进入这些检测前程序是如何处理名字(注册名)和注册码。<a href="fs_获取控件内容.png" data-fancybox="group" data-caption="获取控件内容" class="fancybox"><img width="40%" alt="获取控件内容" title="获取控件内容" data-src="fs_获取控件内容.png" src="/img/loading.gif" class="lazyload"></a>可以看出，注册码被转化为大写，其实在注册码输入框中显示就是大写字母(无论是否切换大小写),之后便判断注册码的长度，如果为0，注册失败。</li><li>接下来是一个遍历注册码(大写)的大循环，每隔5字母中添加一个字符’-‘，最后产生一个新的字符串。<a href="fs_注册码添加'-'.png" data-fancybox="group" data-caption="添加字符'-'" class="fancybox"><img width="40%" alt="添加字符'-'" title="添加字符'-'" data-src="fs_注册码添加'-'.png" src="/img/loading.gif" class="lazyload"></a></li><li>检测1的分析，输入3得到的字符串，将其中的字符’-‘去掉，获得新的字符串。<a href="fs_检测1关键函数.png" data-fancybox="group" data-caption="检测1关键函数" class="fancybox"><img width="40%" alt="检测1关键函数" title="检测1关键函数" data-src="fs_检测1关键函数.png" src="/img/loading.gif" class="lazyload"></a>这是关键函数，判断新的字符串是否在一个列表中，在其中的话，检测1输出1，不在输出0，猜测应该是有系序列号被'拉黑'的非法注册码，要保证合法的注册码不在其中，至于这个列表中到底有那些字符串，并未去深挖，但从运行结果来看，似乎无论输入什么注册码，检测1总是输出0，就好像是摆设一样，所以对其并为过多深究。</li><li>检测2与检测1类似功能。</li><li>检测3的分析，输入步骤3得到的字符串和名字<a href="fs_检测3.png" data-fancybox="group" data-caption="检测3" class="fancybox"><img width="40%" alt="检测3" title="检测3" data-src="fs_检测3.png" src="/img/loading.gif" class="lazyload"></a>要找到什么会影响检测3的输出<a href="检测3-核心函数1.png" data-fancybox="group" data-caption="检测3-核心函数1" class="fancybox"><img width="40%" alt="检测3-核心函数1" title="检测3-核心函数1" data-src="检测3-核心函数1.png" src="/img/loading.gif" class="lazyload"></a>会运行两次检测3-核心函数1，如果两次都输出为0,那么检测3输出为0。 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">检测3-核心函数1的分析</span><br><span class="line">1. 将名字，注册码变成大写</span><br><span class="line">2. 注册码长度应该为20，将注册码中‘-’去掉</span><br><span class="line">3. 提取注册码前8位APAMAIBD</span><br><span class="line">4. 将3得到的注册码放置在名字偶数位中得到HAEPLALMOAIBD</span><br><span class="line">5. 将3得到的注册码另外两个字符串连接</span><br><span class="line">'me4T6cBLV'+</span><br><span class="line">'APAMAIBD'+</span><br><span class="line">'CpCwxrvCJZ30pKLu8Svxjhnhut437glCpofVssnFeBh2G0ekUq4VcxFintMix52vL0iJNbdtWqHPyeumkDUC+4AaoSX+xpl56Esonk4='</span><br><span class="line">6. 根据5得到的字符串用sha1生成blowfish的秘钥</span><br><span class="line">7. 将3得到的注册码与'96338'与4得到的字符串连接</span><br><span class="line">'APAMAIBD'+</span><br><span class="line">'96338'+</span><br><span class="line">'HAEPLALMOAIBD'</span><br><span class="line">8. 根据7得到的字符串用sha512生成idea的秘钥</span><br><span class="line">9. 应用6中的加密系统加密4得到的字符串</span><br><span class="line">GbMe/oqPxOzcvxCYhw==</span><br><span class="line">10. 应用8中的加密系统加密9得到的字符串</span><br><span class="line">aEW7fyam24ntMXjODZBOTMDNPLQ=</span><br><span class="line">11. 提取10中的前8个大写字母</span><br><span class="line">EWMXODZB</span><br><span class="line">12, 比较注册码后8位与11得到的字符串相同则结果为1</span><br></pre></td></tr></tbody></table></figure></div><a href="用sha1生成blowfish密钥.png" data-fancybox="group" data-caption="用sha1生成blowfish密钥" class="fancybox"><img width="40%" alt="用sha1生成blowfish密钥" title="用sha1生成blowfish密钥" data-src="用sha1生成blowfish密钥.png" src="/img/loading.gif" class="lazyload"></a><a href="检测3-核心函数1核心比较.png" data-fancybox="group" data-caption="检测3-核心函数1核心比较" class="fancybox"><img width="40%" alt="检测3-核心函数1核心比较" title="检测3-核心函数1核心比较" data-src="检测3-核心函数1核心比较.png" src="/img/loading.gif" class="lazyload"></a>可以简单总结为，注册码前8位和名字决定了注册码的9-16位。分别用了两次对称加密算法，加密算法用了分别用了SHA1和SHA512来计算密钥。用python来计算生成密钥，结果与程序一致，但是加密结果却不一致，原因未知。</li><li>检测4与与检测3类似，也有一个检测4-核心函数1。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">检测4-核心函数1的分析</span><br><span class="line">1. 将名字，注册码变成大写</span><br><span class="line">2. 注册码长度为20 将注册码中‘-’去掉</span><br><span class="line">3. 提取注册码前8位 APAMAIBD </span><br><span class="line">4. 将3得到的注册码放置在名字偶数位中得到HAEPLALMOAIBD</span><br><span class="line">5. 根据以下字符串(常量)用sha512生成blowfish的秘钥</span><br><span class="line">09232849248398340903834873297239340547237623242043324398489390309284343843223493299435</span><br><span class="line">6. 将3得到的注册码与'96338'与4得到的字符串连接</span><br><span class="line">'APAMAIBD'+</span><br><span class="line">'96338'+</span><br><span class="line">'HAEPLALMOAIBD'</span><br><span class="line">7. 根据6得到的字符串用sha1生成idea的秘钥</span><br><span class="line">8. 用3字符的第一个字母('A')减去0x32得到一个数n=0xF用4得到的字符串,不断用idea加密,次数为n+1得到BQpsiNnacbPngmqP9A==</span><br><span class="line">9. 用blwofish加密8得到的字符串</span><br><span class="line">OgWxUNe+KiqNEnaNt0bk769Yg3A=</span><br><span class="line">10. 提取9中的前4个大写字母</span><br><span class="line">OWUN</span><br><span class="line">11. 比较注册码后4位与10得到的字符串，相同则结果为1</span><br></pre></td></tr></tbody></table></figure></div><a href="用sha512生成blowfish密钥.png" data-fancybox="group" data-caption="用sha512生成blowfish密钥" class="fancybox"><img width="40%" alt="用sha512生成blowfish密钥" title="用sha512生成blowfish密钥" data-src="用sha512生成blowfish密钥.png" src="/img/loading.gif" class="lazyload"></a><a href="循环加密过程.png" data-fancybox="group" data-caption="循环加密过程" class="fancybox"><img width="40%" alt="循环加密过程" title="循环加密过程" data-src="循环加密过程.png" src="/img/loading.gif" class="lazyload"></a><a href="检测4-核心函数1核心比较.png" data-fancybox="group" data-caption="检测4-核心函数1核心比较" class="fancybox"><img width="40%" alt="检测4-核心函数1核心比较" title="检测4-核心函数1核心比较" data-src="检测4-核心函数1核心比较.png" src="/img/loading.gif" class="lazyload"></a>也可以总结为，注册码前8位和名字决定了注册码的后4位。用了与检测3-核心函数1一样的加密算法，但计算密钥的方法调换了。</li><li>通过步骤检测3和检测4的分析可知，注册码长20位，可以根据注册码前8位和名字计算出整个注册码。接下来检测5的分析。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">检测5分析</span><br><span class="line">1. 将名字，注册码变成大写</span><br><span class="line">2. 注册码长度为20 将注册码中‘-’去掉</span><br><span class="line">3. 依次将注册码第4,8,6,2位提取，减去一个常数，转化为字符</span><br><span class="line">第4个 - 4d  > M  </span><br><span class="line">  8   - 44  > D</span><br><span class="line">  6   - 49  > I</span><br><span class="line">  2   - 4f  > O</span><br><span class="line">以上4字符个依次连接，并将生成的字符串转化为数字，要保证数字大于等于1</span><br></pre></td></tr></tbody></table></figure></div>也就是说第4，8，6，2位上的字母需要分别为’M’,’D’,’I’,’O’之后的字母才能保证结果大于等于1。这个结果的大小决定了到底使用了那种许可证。</li><li>综上述，最终的注册码应该为APAMAIBDEWMXODZBOWUN <a href="注册成功.png" data-fancybox="group" data-caption="注册成功" class="fancybox"><img width="40%" alt="注册成功" title="注册成功" data-src="注册成功.png" src="/img/loading.gif" class="lazyload"></a><a href="单一用户许可证.png" data-fancybox="group" data-caption="单一用户许可证" class="fancybox"><img width="40%" alt="单一用户许可证" title="单一用户许可证" data-src="单一用户许可证.png" src="/img/loading.gif" class="lazyload"></a></li><li>显示注册成功之后还有一个步骤，写入数据库，可以通过在读写文件API下断点分析其如何存储用户名以及注册码。</li></ol><h2 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h2><p>本来想用python写注册机，但发现blowfish加密结果与程序实际加密结果不一致，未能编写成功，故尝试用x64dbg脚本。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
          <category> reverse engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64dbg </tag>
            
            <tag> FastStone Capture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2020/02/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/02/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p>格式化字符串漏洞是一种较为常见的漏洞。</p><h2 id="printf-函数声明"><a href="#printf-函数声明" class="headerlink" title="printf()函数声明"></a>printf()函数声明</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, arg1,arg2,arg3,...)</span></span></span><br></pre></td></tr></tbody></table></figure></div><a href="printf栈结构.PNG" data-fancybox="group" data-caption="printf栈结构" class="fancybox"><img height="40%" alt="printf栈结构" align="center" title="printf栈结构" data-src="printf栈结构.PNG" src="/img/loading.gif" class="lazyload"></a>format是字符串，其中，每个"%格式化控制符"对应了一个参数列表的参数，用于解释参数如何输出，"%格式化控制符"可以有以下情况：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%{}$d - 十进制，压入栈的是值，将该值解释为十进制整数</span><br><span class="line">%{}$s - 字符串，压入栈的是字符串地址，读取该地址处的字符串</span><br><span class="line">%{}$x - 十六进制，压入栈的是值，将该值解释为十六进制数</span><br><span class="line">%{}$c - 字符，压入栈的是字符串地址，读取该地址处的字符串</span><br><span class="line">%{}$p - 指针，压入栈的是是一个值，而这个值是地址，相当于以十六进制读该值</span><br><span class="line">%{}$n - 计算到目前为止所输出的字符数，写入对应位置的参数，该参数为一个地址</span><br><span class="line">{}$可以省略，其中{}用数字代替，如%3$d，表示以十进制整数的形式输出第3个参数。</span><br></pre></td></tr></tbody></table></figure></div><h2 id="漏洞形成原理"><a href="#漏洞形成原理" class="headerlink" title="漏洞形成原理"></a>漏洞形成原理</h2><p>因为printf的参数可以变化，其参数是从右往左依次压入栈，最后一个压入的是format字符串的地址。所以在解析参数时，printf会试图为format string中每一个%找一个与之对应的参数这就导致了漏洞的产生。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>以上程序中</p><ul><li>如果输入a中不包含%是不会问题的，但是一旦包含了%，printf就会认为有多个参数，在栈上找参数，从而可以实现对内存的读写。</li><li>要存在一个程序输入点能够输入字符串，而且输入的字符串作为了printf的format string参数，这样才能利用这个漏洞。</li></ul><h2 id="对任意地址读"><a href="#对任意地址读" class="headerlink" title="对任意地址读"></a>对任意地址读</h2><p>正常format string的是在各个参数argn的上方(以为栈是向低处生长)。<br><a href="fmt_string的位置.PNG" data-fancybox="group" data-caption="fmt_string的位置" class="fancybox"><img height="40%" alt="fmt_string的位置" align="center" title="fmt_string的位置" data-src="fmt_string的位置.PNG" src="/img/loading.gif" class="lazyload"></a><br>要实现读任意地址，要做到</p><ul><li>format string包含具体读的地址</li><li>format string包含如何读该地址，通过格式化控制符实现</li></ul><p>格式化控制符与栈上的参数一一对应，第一个%对应arg1,第二个%对应arg2,那么意味着’具体要读的地址’对应着一个argn，这就意味着要精准控制format string在栈中与各个argn的位置关系。此时变成<br><a href="任意读的栈结构.PNG" data-fancybox="group" data-caption="任意读的栈结构" class="fancybox"><img height="40%" alt="任意读的栈结构" align="center" title="任意读的栈结构" data-src="任意读的栈结构.PNG" src="/img/loading.gif" class="lazyload"></a><br>可以看出，有些栈上的内容根本无法通过format string控制，所以需要知道format string在栈上偏移多少，从那个argn开始覆盖,这需要通过测试得知。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><a href="fmt_string偏移.PNG" data-fancybox="group" data-caption="fmt_string偏移" class="fancybox"><img height="40%" alt="fmt_string偏移" align="center" title="fmt_string偏移" data-src="fmt_string偏移.PNG" src="/img/loading.gif" class="lazyload"></a>这说明输入的'AAAA%6$x'的地址是从arg6开始的，似乎可以看出format string存储地址与栈是对齐的，这应该是一般规则，因为这样存取速度更快，当然以上程序还有缓冲区溢出漏洞，在溢出攻击中，要确定的是返回地址的在输入字符串的偏移。一旦确认了偏移，就可以着手构造要读的地址了。构造的时候要注意的是小端还是大端。<h2 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h2><p>要实现写任意地址，要做到</p><ul><li>format string包含具体写的地址</li><li>format string包含写的内容</li><li>format string包含%n，</li></ul><p>%n对应具体写的地址，而内容是通过%n前面已有的字符长度来计算，但很多时候有输入长度限制，若是要写入的值是100，不可能真的输入100个字符，可以通过以下方式解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span>  str1 []= <span class="string">"AAAA"</span>;</span><br><span class="line">    <span class="keyword">char</span>  str2[] = <span class="string">"aaaa"</span>;</span><br><span class="line">    <span class="keyword">int</span> a  = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%10s%2$n \n"</span>,str1,&a );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %c %c %c %d\n"</span>,str2[<span class="number">0</span>],str2[<span class="number">1</span>],str2[<span class="number">2</span>],str2[<span class="number">3</span>],a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><a href="写的例子.PNG" data-fancybox="group" data-caption="写的例子" class="fancybox"><img height="40%" alt="写的例子" align="center" title="写的例子" data-src="写的例子.PNG" src="/img/loading.gif" class="lazyload"></a><h2 id="读写备忘录"><a href="#读写备忘录" class="headerlink" title="读写备忘录"></a>读写备忘录</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">这部分来自icemakr的博客</span><br><span class="line"></span><br><span class="line">32位</span><br><span class="line"></span><br><span class="line">读</span><br><span class="line"></span><br><span class="line">'%{}$x'.format(index)           // 读4个字节</span><br><span class="line">'%{}$p'.format(index)           // 同上面</span><br><span class="line">'${}$s'.format(index)</span><br><span class="line">写</span><br><span class="line"></span><br><span class="line">'%{}$n'.format(index)           // 解引用，写入四个字节</span><br><span class="line">'%{}$hn'.format(index)          // 解引用，写入两个字节</span><br><span class="line">'%{}$hhn'.format(index)         // 解引用，写入一个字节</span><br><span class="line">'%{}$lln'.format(index)         // 解引用，写入八个字节</span><br><span class="line"></span><br><span class="line">////////////////////////////</span><br><span class="line">64位</span><br><span class="line"></span><br><span class="line">读</span><br><span class="line"></span><br><span class="line">'%{}$x'.format(index, num)      // 读4个字节</span><br><span class="line">'%{}$lx'.format(index, num)     // 读8个字节</span><br><span class="line">'%{}$p'.format(index)           // 读8个字节</span><br><span class="line">'${}$s'.format(index)</span><br><span class="line">写</span><br><span class="line"></span><br><span class="line">'%{}$n'.format(index)           // 解引用，写入四个字节</span><br><span class="line">'%{}$hn'.format(index)          // 解引用，写入两个字节</span><br><span class="line">'%{}$hhn'.format(index)         // 解引用，写入一个字节</span><br><span class="line">'%{}$lln'.format(index)         // 解引用，写入八个字节</span><br><span class="line"></span><br><span class="line">%1$lx: RSI</span><br><span class="line">%2$lx: RDX</span><br><span class="line">%3$lx: RCX</span><br><span class="line">%4$lx: R8</span><br><span class="line">%5$lx: R9</span><br><span class="line">%6$lx: 栈上的第一个QWORD</span><br></pre></td></tr></tbody></table></figure></div><h2 id="pwntools构造方式"><a href="#pwntools构造方式" class="headerlink" title="pwntools构造方式"></a><a href="https://pwntools.readthedocs.io/en/stable/fmtstr.html" target="_blank" rel="noopener">pwntools构造方式</a></h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">格式化字符串漏洞学习</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
          <category> format string </category>
          
      </categories>
      
      
        <tags>
            
            <tag> printf </tag>
            
            <tag> ctf </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
